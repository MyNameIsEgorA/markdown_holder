##### lea
```
lea destination, source
```
Записывает адрес source в destination

##### lodsb (load string byte)
```
lea si origin
lodsb
```
lodsb записывает значение, по адресу, который записан в si, в al и увеличивает si на 1


##### int 21h
Выполняет прерывание, номер которого записан в AH



##### stosb
Сохраняет значение из регистра AL, в память по адресу DI, а затем увеличивает DI на 1



### Исходный код

```
EOFLine EQU '$'  ; Определяем символ конца строки ('$') как константу EOFLine
INT_1C EQU 1Ch   ; Определяем константу для прерывания INT 1C (таймер)

AStack SEGMENT STACK  ; Определяем сегмент стека
DW 1024 DUP(?)        ; Выделяем 1024 слова памяти для стека
AStack ENDS           ; Завершаем сегмент стека

DATA SEGMENT          ; Начало сегмента данных
	max_len equ 64h       ; Максимальная длина строки (100 символов)
	OriginHeader DB max_len, 0h  ; Заголовок для ввода строки (длина и нулевой байт)
	origin DB max_len DUP('?'), 0dh, 0ah, '$'  ; Буфер для ввода строки (заполнен символами '?', затем CR, LF, '$')
	FooHeader DB max_len, 0h  ; Заголовок для второй строки
	foo DB max_len dup('?'), 0dh, 0ah, '$'  ; Буфер для второй строки
	res DB max_len DUP('?'), 0dh, 0ah, '$'  ; Буфер для результата
	greeting DB 'Добро пожаловать в программу для обработки строк', 0dh, 0ah, '$'  ; Приветственное сообщение
	waiting DB 'Введите строку:', 0dh, 0ah, '$'  ; Сообщение для ввода строки
	cnt DW -1  ; Счетчик для подсчета символов
	number dw 0  ; Переменная для хранения числа
	converterCnt dw 0  ; Счетчик для преобразования числа в строку
	OLD_1C_CS DW 0  ; Сохраняем старый сегмент обработчика INT 1C
    OLD_1C_IP DW 0  ; Сохраняем старое смещение обработчика INT 1C
	ticks     DW 0  ; Счетчик тиков таймера
	n DW 7  ; Количество тиков для срабатывания обработчика
DATA ENDS  ; Завершаем сегмент данных

CODE SEGMENT  ; Начало сегмента кода
  ASSUME CS:CODE, DS:DATA, SS:AStack  ; Указываем, что CS указывает на сегмент кода, DS на данные, SS на стек

; Основная процедура программы
Main PROC
	; Инициализация
	push ds         ; Сохраняем текущий сегмент данных (DS) на стек
	sub ax, ax      ; Обнуляем регистр AX (AX = 0)
	push ax         ; Сохраняем 0 на стеке (для восстановления PSP)
	mov ax, DATA    ; Загружаем сегмент данных в AX
	mov ds, ax      ; Устанавливаем DS на сегмент данных
	mov es, ax      ; Устанавливаем ES на сегмент данных

	; Вывод приветствия
	mov dx, offset greeting ; Указываем на строку приветствия
	call Print      		; Вызываем процедуру вывода строки
	mov dx, offset waiting 	; Указываем на строку с предложением ввода
	call Print      		; Вызываем процедуру вывода строки

	; Ввод первой строки
	mov dx, offset OriginHeader	; Указываем на заголовок для ввода
	call ReadString      	; Вызываем процедуру ввода строки

	; Сохранение регистров перед обработкой строки
	push si					; Сохраняем SI (регистр для работы со строками)
	push ax					; Сохраняем AX (регистр для вычислений)
	push bx					; Сохраняем BX (регистр для временных данных)

	; Загрузка адреса строки в SI
	lea si, origin			; Загружаем адрес строки в SI

	; Загрузка первого символа строки в AL
	lodsb					; Загружаем первый символ строки (символ, на который указывает SI) и увеличиваем значение si на 1

	; Проверка, является ли символ цифрой
	cmp al, '0'				; Сравниваем AL с '0'
	jl Skip					; Если AL меньше '0', переходим к метке Skip
	cmp al, '9'				; Сравниваем AL с '9'
	jg Skip					; Если AL больше '9', переходим к метке Skip

	; Преобразование ASCII-цифры в число
	mov bl, 10				; Загружаем 10 в BL (для умножения)
	sub al, '0'				; Преобразуем ASCII-цифру в число
	mul bl					; Умножаем AL на 10 (для десятков)
	mov n, ax				; Сохраняем результат в переменной n

Skip:
	; Восстановление регистров
	pop bx					; Восстанавливаем BX
	pop ax					; Восстанавливаем AX
	pop si					; Восстанавливаем SI

	; Сохранение старого обработчика INT 1C
	mov ah, 35h  ; Функция DOS для получения адреса обработчика прерывания
    mov al, INT_1C  ; Номер прерывания (1C)
    int 21h  ; Вызов DOS
    mov OLD_1C_CS, ES     ; Сохраняем сегмент старого обработчика
    mov OLD_1C_IP, BX     ; Сохраняем смещение старого обработчика

	; Установка нового обработчика INT 1C
	PUSH ds  ; Сохраняем текущий DS
    mov  dx, offset New1C ; Указываем на новый обработчик
    mov  ax, seg New1C    ; Загружаем сегмент нового обработчика
    mov  ds, ax  ; Устанавливаем DS на сегмент нового обработчика
    mov  ah, 25h  ; Функция DOS для установки нового обработчика прерывания
    mov  al, INT_1C  ; Номер прерывания (1C)
    int  21h  ; Вызов DOS
    pop  ds  ; Восстанавливаем DS
	
	; Ввод второй строки
	mov dx, offset FooHeader	; Указываем на заголовок для ввода
	call ReadString      		; Вызываем процедуру ввода строки

	; Завершение программы
	mov ah, 4Ch    ; Функция DOS для завершения программы
	mov al, 0      ; Код завершения 0
	int 21h         ; Завершаем программу
Main ENDP

; Процедура вывода строки на экран
Print PROC NEAR
	mov ah, 9    ; Функция DOS для вывода строки на экран
	int 21h      ; Вызов DOS
	ret          ; Возврат из процедуры
Print ENDP

; Процедура ввода строки с клавиатуры
ReadString PROC NEAR
	mov ah,0ah  ; Функция DOS для ввода строки
	push dx     ; Сохраняем DX
	int 21h     ; Вызов DOS
	pop bp      ; Восстанавливаем BP
	xor bx,bx   ; Обнуляем BX
	mov bl,ds:[bp+1]  ; Загружаем длину строки в BL
	add bx,bp   ; Вычисляем адрес конца строки
	add bx,2    ; Добавляем смещение для символов CR и LF
	mov word ptr [bx+1],240ah  ; Добавляем символы CR и LF
	mov ds:[bp+1], bl  ; Сохраняем длину строки
	ret                ; Возврат из процедуры
ReadString ENDP

; Процедура преобразования строки
ConvertString PROC NEAR
	mov ax, SEG res			; Загружаем сегмент результата
	mov es, ax     			; Устанавливаем ES на сегмент результата

	lea si, origin 			; Загружаем адрес исходной строки
	lea di, res    			; Загружаем адрес результата

	mov bx, offset OriginHeader 	; Загружаем адрес заголовка
	mov cl , [bx+1]       	; Загружаем длину строки в CL
	add cl,1

StringLoop:    		; Цикл обработки строки
	cmp cx, 0     	; Проверяем, остались ли символы
	je StringEnd   	; Если нет, завершаем цикл
	
	push ax    		; Сохраняем AX
	mov ax, cnt 	; Загружаем счетчик
	add ax, 1  		; Увеличиваем счетчик
	mov cnt, ax 	; Сохраняем счетчик
	pop ax    		; Восстанавливаем AX

	lodsb           ; Загружаем символ, на который указывает SI, из строки в AL
	cmp al, 'D'     ; Проверяем, равен ли символ 'D'
	jne StringNext 	; Если нет, переходим к следующему символу

ConvertIndex:    	; Обработка символа 'D'
	push cx         ; Сохраняем значение CX на стеке, чтобы не потерять его
	mov cx, cnt     ; Загружаем текущее значение счетчика символов (cnt) в CX
	mov number, cx  ; Сохраняем значение счетчика в переменной number (для преобразования в строку)
	push ax         ; Сохраняем значение AX на стеке
	push dx         ; Сохраняем значение DX на стеке

	IndexLoop:      ; Начало цикла для преобразования числа в строку
		mov ax, converterCnt ; Загружаем текущее значение converterCnt (счетчик преобразований) в AX
		add ax, 1            ; Увеличиваем счетчик преобразований на 1
		mov converterCnt, ax ; Сохраняем обновленное значение converterCnt

		mov cx, number       ; Загружаем текущее число (number) в CX
		mov ax, cx           ; Копируем число из CX в AX (AX - текущее число)
		mov dl, 10           ; Загружаем делитель 10 в DL (для деления на 10)
		div dl               ; Делим AX на 10 (частное в AL, остаток в AH)
		mov number, al       ; Сохраняем частное (оставшееся число) в number
		add ah, '0'          ; Преобразуем остаток (цифру) в ASCII-символ (добавляем '0')
		mov al, ah           ; Копируем ASCII-символ из AH в AL
		push ax              ; Сохраняем ASCII-символ (в AL) на стеке

		mov cx, number       ; Загружаем оставшееся число (number) в CX
		cmp cx, 0            ; Сравниваем оставшееся число с 0
		jne IndexLoop        ; Если число не равно 0, повторяем цикл IndexLoop

	ReverseLoop:             ; Начало цикла для разворота строки
		mov dx, converterCnt ; Загружаем текущее значение converterCnt в DX
		sub dx, 1            ; Уменьшаем счетчик converterCnt на 1
		mov converterCnt, dx ; Сохраняем обновленное значение converterCnt

		pop ax               ; Извлекаем символ из стека (в AL)
		stosb                ; Сохраняем символ, записанный в AL в память по адресу, который записан в DI, DI++
		cmp dx, 0            ; Сравниваем текущее значение converterCnt с 0
		jne ReverseLoop      ; Если converterCnt не равно 0, повторяем цикл ReverseLoop

	pop dx       ; Восстанавливаем значение DX из стека
	pop ax       ; Восстанавливаем значение AX из стека
	mov al, 32   ; Загружаем символ пробела в AL
	stosb        ; Сохраняем значение из AL (символ пробела) по адресу, на который указывает DI, DI++
	pop cx       ; Восстанавливаем значение CX из стека

	StringNext:     ; Переход к следующему символу
	dec cx         ; Уменьшаем счетчик символов (CX) на 1
	jmp StringLoop  ; Переходим к следующему символу в строке

	StringEnd:      ; Конец строки
	mov al, EOFLine ; Загружаем символ конца строки ('$') в AL
	stosb           ; Сохраняем символ конца строки в результирующую строку (DI)
	ret             ; Возврат из процедуры

ConvertString ENDP

; Новый обработчик прерывания INT 1C
New1C PROC FAR
	;;;;
    inc ticks
	push dx
	mov dx, n
    CMP ticks, dx ; Сравниваем счетчик тиков с заданным значением
	pop dx
    jl  ext
	
	call ConvertString

	; Вывод результата
	mov dx, offset origin; Указываем на исходную строку
	call Print         ; Выводим исходную строку
	mov dx, offset res   ; Указываем на результат
	call Print           ; Выводим результат
	
	; Восстановление дефолтного обработчика 1ch
    push ds           ; Сохраняем ds
    mov dx, OLD_1C_IP ; Переносим старое значение IP прерывания в dx
    mov ax, OLD_1C_CS ; Переносим старое значение CS прерывания в ax
    mov ds, ax        ; Переносим значение AX в DS
    mov ah, 25h       ; Устанавливаем в AH функцию 25h, которая используется для установки обработчика прерывания
    mov al, 1ch       ; Устанавливаем в al прерывание 1ch,  
    int 21h           ; Вызываем прерывание 1ch из al
    pop ds            ; Возвращаем ds

ext:
    iret
New1C  ENDP

CODE ENDS
END Main

```
